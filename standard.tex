\documentclass[12pt, a4paper]{IEEEtran}
\title{Standard for The Set Programming Language}
\author{Jedi Yang}

\usepackage{indentfirst}

\begin{document}
\maketitle

\section{Data Structure}
	The Set Programming Language aims at using sets and assist with vectors to build a Functional Programming Language. The data structure of Set is more important than language and grammar.

\subsection{Atom}
	Atom is the fundamental unit of Set. It means a set with only one number, either an integer or a decimal, but only numbers are stored in atoms.
	
	An atom can be expressed as $\{A\}$, but it can also be simplified as $A$. However, these two expression are different when doing calculation:
	
	$\{A\} + \{B\} == \{A, B\}$ while $A + B$ is the sum of number $A$ and $B$.
	
	An Atom with brackets around accept Set Operations while an atom without brackets accept Basic Operations (see Operations)
	
	\subsubsection{Number}
	Due to IEEE 754, if an integer is stored in a float or double, it is almost impossible to determine whether the number is an integer. The numbers in Set Programming Language use Irreducible Fractions to store both integers and decimals. An irreducible fraction contains two integers, a denominator and a numerator. Atoms can only store Irreducible Fractions.
	\subsubsection{Boolean}
	Boolean is special number with true and false only. Typically an atom of 0/0 is false. A set containing value 0/0 is also false. Otherwise, valid numbers and sets are seen as true including zero. During comparison, true is returned as {1/1} and false is {0/0}.

\subsection{Set}
	Set is a new data structure that is rare in other programming languages. It is similar to an Array, but there are two restrictions:
	\begin{enumerate}
	\item A set has no two identical numbers
	\item A set is ordered. The smallest is the head of the set.
	\end{enumerate}
	If a set does not meet the restrictions, identical numbers should be reduced and values are sorted automatically. Set can be catagorized into Enumerative Sets and Conditional Sets.
	
	\subsubsection{Enumerative Sets}
	This branch contains sets such that all numbers within the sets are listed. Enumerative Sets are stored in linked lists, with the smallest number is the head. All enumerative sets are finite.
		
	For example: $\{1, 3, 5, 17/2, 10\}$ is an enumerative set.
		
	\subsubsection{Conditional Sets}
	This branch contains sets such that numbers are determined by an operation and conditions. Not all conditional sets are infinite, some of them can be listed out. 
		
	For example: $\{x:2x+7|2<x<7\}$ is a conditional set.
		
	%If the conditional set has less than one thousand numbers, the runtime should be able to convert the conditional set into an enumerative set
\subsection{Vector}
	Vector is another name for Array. However, Vectors should accept vector operations such as dot product and it only accepts Numbers. Vectors and Sets are similar. Vectors are also stored in linked lists. The difference between Vectors and Sets are that vectors do not have restrictions for sets:
	\begin{enumerate}
	\item A vector can have two identical numbers
	\item A vector can be randomly sorted.
	\end{enumerate}
	There is a special form of Vector. Transformation Vector.
	
	\subsubsection{Transformation Vector}
	This is vector that describes a series of transformation to one or more than one variables. In transformation vectors, Functions are stored. The return values of the prior function acts as the arguments for the next one.
	
	\subsubsection{Function}
	It is similar to Lambda Expressions in other programming languages. A function can only support one line of code. Except the return values and arguments of a function, the function cannot use other variables. Functions are better used in transformation vectors to support complex operations.
	
\subsection{String}
	String is a special vector, similar to most programming languages. However, it should have a different implementation using consequtive memory spaces.
	
\section{Operation}
\subsection{Numbers}
	Unary Operation
	\begin{enumerate}
		\item -x
	\end{enumerate}
	Binary Operation: 
	\begin{enumerate}
		\item x+y
		\item x-y
		\item x*y
		\item x/y
		\item x\%y
		\item x\&y
		\item x$|$y
		\item x==y
		\item x!=y
		\item x>y
		\item x<y
		\item x>=y
		\item x<=y
		\item x\&\&y
		\item x$||$y
	\end{enumerate}
\subsection{Set \& Number}
	Binary Operation:
	\begin{enumerate}
		\item s+x == s.append(x)
		\item s-x == s.remove(x)
		\item s*x == s.forEach({this$\sim$this*x})
		\item s/x == s.forEach({this$\sim$this/x})
		\item s\%x ==s.forEach({this$\sim$this\%x})
	\end{enumerate}
\subsection{Sets}
	Binary Operation:
	\begin{enumerate}
		\item u+v == v.forEach(u.append)
		\item u-v == v.forEach(u.remove)
		\item u*v == v.forEach(u.exist)
		\item u/v == (u+v).forEach(xnor(u.exist,v.exist))
	\end{enumerate}
\end{document}